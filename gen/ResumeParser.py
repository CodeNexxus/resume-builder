# Generated from C:/Users/pars/Desktop/code nuxxus/grammar/Resume.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,35,514,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,1,0,1,0,1,0,1,1,1,1,5,1,76,8,1,10,1,12,1,79,9,1,1,
        1,3,1,82,8,1,1,1,5,1,85,8,1,10,1,12,1,88,9,1,1,1,3,1,91,8,1,1,1,
        5,1,94,8,1,10,1,12,1,97,9,1,1,1,3,1,100,8,1,1,1,5,1,103,8,1,10,1,
        12,1,106,9,1,1,1,3,1,109,8,1,1,1,5,1,112,8,1,10,1,12,1,115,9,1,1,
        1,3,1,118,8,1,1,1,5,1,121,8,1,10,1,12,1,124,9,1,1,1,3,1,127,8,1,
        1,1,5,1,130,8,1,10,1,12,1,133,9,1,1,1,3,1,136,8,1,1,2,1,2,1,2,1,
        2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,
        2,1,2,1,3,4,3,160,8,3,11,3,12,3,161,1,4,4,4,165,8,4,11,4,12,4,166,
        1,5,4,5,170,8,5,11,5,12,5,171,1,6,4,6,175,8,6,11,6,12,6,176,1,7,
        1,7,1,8,4,8,182,8,8,11,8,12,8,183,1,9,1,9,1,10,1,10,4,10,190,8,10,
        11,10,12,10,191,1,10,1,10,1,11,1,11,5,11,198,8,11,10,11,12,11,201,
        9,11,1,11,3,11,204,8,11,1,11,5,11,207,8,11,10,11,12,11,210,9,11,
        1,11,3,11,213,8,11,1,12,1,12,1,12,1,12,1,13,5,13,220,8,13,10,13,
        12,13,223,9,13,1,14,4,14,226,8,14,11,14,12,14,227,1,14,1,14,1,14,
        1,14,1,15,1,15,1,15,1,15,1,16,5,16,239,8,16,10,16,12,16,242,9,16,
        1,17,4,17,245,8,17,11,17,12,17,246,1,17,1,17,1,18,1,18,1,18,1,18,
        1,19,5,19,256,8,19,10,19,12,19,259,9,19,1,20,1,20,1,20,1,21,1,21,
        5,21,266,8,21,10,21,12,21,269,9,21,1,21,1,21,1,22,5,22,274,8,22,
        10,22,12,22,277,9,22,1,23,1,23,4,23,281,8,23,11,23,12,23,282,1,23,
        5,23,286,8,23,10,23,12,23,289,9,23,1,23,1,23,4,23,293,8,23,11,23,
        12,23,294,1,23,5,23,298,8,23,10,23,12,23,301,9,23,1,23,1,23,1,23,
        5,23,306,8,23,10,23,12,23,309,9,23,1,24,1,24,1,24,1,24,1,25,5,25,
        316,8,25,10,25,12,25,319,9,25,1,26,1,26,1,26,1,26,1,26,1,27,1,27,
        5,27,328,8,27,10,27,12,27,331,9,27,1,27,1,27,1,27,1,27,5,27,337,
        8,27,10,27,12,27,340,9,27,1,28,1,28,4,28,344,8,28,11,28,12,28,345,
        1,28,5,28,349,8,28,10,28,12,28,352,9,28,1,28,1,28,4,28,356,8,28,
        11,28,12,28,357,1,28,5,28,361,8,28,10,28,12,28,364,9,28,1,28,1,28,
        1,28,5,28,369,8,28,10,28,12,28,372,9,28,1,29,1,29,5,29,376,8,29,
        10,29,12,29,379,9,29,1,29,1,29,1,29,1,29,5,29,385,8,29,10,29,12,
        29,388,9,29,1,30,1,30,4,30,392,8,30,11,30,12,30,393,1,30,5,30,397,
        8,30,10,30,12,30,400,9,30,1,30,1,30,4,30,404,8,30,11,30,12,30,405,
        1,30,5,30,409,8,30,10,30,12,30,412,9,30,1,30,1,30,4,30,416,8,30,
        11,30,12,30,417,1,30,5,30,421,8,30,10,30,12,30,424,9,30,1,30,1,30,
        4,30,428,8,30,11,30,12,30,429,1,30,5,30,433,8,30,10,30,12,30,436,
        9,30,1,30,1,30,1,30,1,30,1,31,1,31,1,31,5,31,445,8,31,10,31,12,31,
        448,9,31,1,32,4,32,451,8,32,11,32,12,32,452,1,33,1,33,1,33,1,33,
        1,33,1,33,5,33,461,8,33,10,33,12,33,464,9,33,1,34,1,34,4,34,468,
        8,34,11,34,12,34,469,1,34,5,34,473,8,34,10,34,12,34,476,9,34,1,34,
        1,34,4,34,480,8,34,11,34,12,34,481,1,34,5,34,485,8,34,10,34,12,34,
        488,9,34,1,34,1,34,4,34,492,8,34,11,34,12,34,493,1,34,5,34,497,8,
        34,10,34,12,34,500,9,34,1,34,1,34,4,34,504,8,34,11,34,12,34,505,
        1,34,5,34,509,8,34,10,34,12,34,512,9,34,1,34,0,0,35,0,2,4,6,8,10,
        12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,
        56,58,60,62,64,66,68,0,0,543,0,70,1,0,0,0,2,73,1,0,0,0,4,137,1,0,
        0,0,6,159,1,0,0,0,8,164,1,0,0,0,10,169,1,0,0,0,12,174,1,0,0,0,14,
        178,1,0,0,0,16,181,1,0,0,0,18,185,1,0,0,0,20,187,1,0,0,0,22,195,
        1,0,0,0,24,214,1,0,0,0,26,221,1,0,0,0,28,225,1,0,0,0,30,233,1,0,
        0,0,32,240,1,0,0,0,34,244,1,0,0,0,36,250,1,0,0,0,38,257,1,0,0,0,
        40,260,1,0,0,0,42,263,1,0,0,0,44,275,1,0,0,0,46,278,1,0,0,0,48,310,
        1,0,0,0,50,317,1,0,0,0,52,320,1,0,0,0,54,325,1,0,0,0,56,341,1,0,
        0,0,58,373,1,0,0,0,60,389,1,0,0,0,62,441,1,0,0,0,64,450,1,0,0,0,
        66,454,1,0,0,0,68,465,1,0,0,0,70,71,3,2,1,0,71,72,5,0,0,1,72,1,1,
        0,0,0,73,77,3,4,2,0,74,76,5,35,0,0,75,74,1,0,0,0,76,79,1,0,0,0,77,
        75,1,0,0,0,77,78,1,0,0,0,78,81,1,0,0,0,79,77,1,0,0,0,80,82,3,20,
        10,0,81,80,1,0,0,0,81,82,1,0,0,0,82,86,1,0,0,0,83,85,5,35,0,0,84,
        83,1,0,0,0,85,88,1,0,0,0,86,84,1,0,0,0,86,87,1,0,0,0,87,90,1,0,0,
        0,88,86,1,0,0,0,89,91,3,22,11,0,90,89,1,0,0,0,90,91,1,0,0,0,91,95,
        1,0,0,0,92,94,5,35,0,0,93,92,1,0,0,0,94,97,1,0,0,0,95,93,1,0,0,0,
        95,96,1,0,0,0,96,99,1,0,0,0,97,95,1,0,0,0,98,100,3,42,21,0,99,98,
        1,0,0,0,99,100,1,0,0,0,100,104,1,0,0,0,101,103,5,35,0,0,102,101,
        1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,1,0,0,0,105,108,
        1,0,0,0,106,104,1,0,0,0,107,109,3,48,24,0,108,107,1,0,0,0,108,109,
        1,0,0,0,109,113,1,0,0,0,110,112,5,35,0,0,111,110,1,0,0,0,112,115,
        1,0,0,0,113,111,1,0,0,0,113,114,1,0,0,0,114,117,1,0,0,0,115,113,
        1,0,0,0,116,118,3,54,27,0,117,116,1,0,0,0,117,118,1,0,0,0,118,122,
        1,0,0,0,119,121,5,35,0,0,120,119,1,0,0,0,121,124,1,0,0,0,122,120,
        1,0,0,0,122,123,1,0,0,0,123,126,1,0,0,0,124,122,1,0,0,0,125,127,
        3,58,29,0,126,125,1,0,0,0,126,127,1,0,0,0,127,131,1,0,0,0,128,130,
        5,35,0,0,129,128,1,0,0,0,130,133,1,0,0,0,131,129,1,0,0,0,131,132,
        1,0,0,0,132,135,1,0,0,0,133,131,1,0,0,0,134,136,3,66,33,0,135,134,
        1,0,0,0,135,136,1,0,0,0,136,3,1,0,0,0,137,138,5,1,0,0,138,139,3,
        6,3,0,139,140,5,35,0,0,140,141,5,2,0,0,141,142,3,8,4,0,142,143,5,
        35,0,0,143,144,5,3,0,0,144,145,3,10,5,0,145,146,5,35,0,0,146,147,
        5,4,0,0,147,148,3,14,7,0,148,149,5,35,0,0,149,150,5,5,0,0,150,151,
        3,16,8,0,151,152,5,35,0,0,152,153,5,6,0,0,153,154,3,18,9,0,154,155,
        5,35,0,0,155,156,5,7,0,0,156,157,3,12,6,0,157,5,1,0,0,0,158,160,
        5,29,0,0,159,158,1,0,0,0,160,161,1,0,0,0,161,159,1,0,0,0,161,162,
        1,0,0,0,162,7,1,0,0,0,163,165,5,29,0,0,164,163,1,0,0,0,165,166,1,
        0,0,0,166,164,1,0,0,0,166,167,1,0,0,0,167,9,1,0,0,0,168,170,5,29,
        0,0,169,168,1,0,0,0,170,171,1,0,0,0,171,169,1,0,0,0,171,172,1,0,
        0,0,172,11,1,0,0,0,173,175,5,29,0,0,174,173,1,0,0,0,175,176,1,0,
        0,0,176,174,1,0,0,0,176,177,1,0,0,0,177,13,1,0,0,0,178,179,5,30,
        0,0,179,15,1,0,0,0,180,182,5,29,0,0,181,180,1,0,0,0,182,183,1,0,
        0,0,183,181,1,0,0,0,183,184,1,0,0,0,184,17,1,0,0,0,185,186,5,31,
        0,0,186,19,1,0,0,0,187,189,5,8,0,0,188,190,5,29,0,0,189,188,1,0,
        0,0,190,191,1,0,0,0,191,189,1,0,0,0,191,192,1,0,0,0,192,193,1,0,
        0,0,193,194,5,35,0,0,194,21,1,0,0,0,195,199,3,24,12,0,196,198,5,
        35,0,0,197,196,1,0,0,0,198,201,1,0,0,0,199,197,1,0,0,0,199,200,1,
        0,0,0,200,203,1,0,0,0,201,199,1,0,0,0,202,204,3,30,15,0,203,202,
        1,0,0,0,203,204,1,0,0,0,204,208,1,0,0,0,205,207,5,35,0,0,206,205,
        1,0,0,0,207,210,1,0,0,0,208,206,1,0,0,0,208,209,1,0,0,0,209,212,
        1,0,0,0,210,208,1,0,0,0,211,213,3,36,18,0,212,211,1,0,0,0,212,213,
        1,0,0,0,213,23,1,0,0,0,214,215,5,9,0,0,215,216,5,35,0,0,216,217,
        3,26,13,0,217,25,1,0,0,0,218,220,3,28,14,0,219,218,1,0,0,0,220,223,
        1,0,0,0,221,219,1,0,0,0,221,222,1,0,0,0,222,27,1,0,0,0,223,221,1,
        0,0,0,224,226,5,29,0,0,225,224,1,0,0,0,226,227,1,0,0,0,227,225,1,
        0,0,0,227,228,1,0,0,0,228,229,1,0,0,0,229,230,5,10,0,0,230,231,5,
        29,0,0,231,232,5,35,0,0,232,29,1,0,0,0,233,234,5,11,0,0,234,235,
        5,35,0,0,235,236,3,32,16,0,236,31,1,0,0,0,237,239,3,34,17,0,238,
        237,1,0,0,0,239,242,1,0,0,0,240,238,1,0,0,0,240,241,1,0,0,0,241,
        33,1,0,0,0,242,240,1,0,0,0,243,245,5,29,0,0,244,243,1,0,0,0,245,
        246,1,0,0,0,246,244,1,0,0,0,246,247,1,0,0,0,247,248,1,0,0,0,248,
        249,5,35,0,0,249,35,1,0,0,0,250,251,5,12,0,0,251,252,5,35,0,0,252,
        253,3,38,19,0,253,37,1,0,0,0,254,256,3,40,20,0,255,254,1,0,0,0,256,
        259,1,0,0,0,257,255,1,0,0,0,257,258,1,0,0,0,258,39,1,0,0,0,259,257,
        1,0,0,0,260,261,5,29,0,0,261,262,5,35,0,0,262,41,1,0,0,0,263,267,
        5,13,0,0,264,266,5,35,0,0,265,264,1,0,0,0,266,269,1,0,0,0,267,265,
        1,0,0,0,267,268,1,0,0,0,268,270,1,0,0,0,269,267,1,0,0,0,270,271,
        3,44,22,0,271,43,1,0,0,0,272,274,3,46,23,0,273,272,1,0,0,0,274,277,
        1,0,0,0,275,273,1,0,0,0,275,276,1,0,0,0,276,45,1,0,0,0,277,275,1,
        0,0,0,278,280,5,1,0,0,279,281,5,29,0,0,280,279,1,0,0,0,281,282,1,
        0,0,0,282,280,1,0,0,0,282,283,1,0,0,0,283,287,1,0,0,0,284,286,5,
        35,0,0,285,284,1,0,0,0,286,289,1,0,0,0,287,285,1,0,0,0,287,288,1,
        0,0,0,288,290,1,0,0,0,289,287,1,0,0,0,290,292,5,14,0,0,291,293,5,
        29,0,0,292,291,1,0,0,0,293,294,1,0,0,0,294,292,1,0,0,0,294,295,1,
        0,0,0,295,299,1,0,0,0,296,298,5,35,0,0,297,296,1,0,0,0,298,301,1,
        0,0,0,299,297,1,0,0,0,299,300,1,0,0,0,300,302,1,0,0,0,301,299,1,
        0,0,0,302,303,5,15,0,0,303,307,5,32,0,0,304,306,5,35,0,0,305,304,
        1,0,0,0,306,309,1,0,0,0,307,305,1,0,0,0,307,308,1,0,0,0,308,47,1,
        0,0,0,309,307,1,0,0,0,310,311,5,16,0,0,311,312,5,35,0,0,312,313,
        3,50,25,0,313,49,1,0,0,0,314,316,3,52,26,0,315,314,1,0,0,0,316,319,
        1,0,0,0,317,315,1,0,0,0,317,318,1,0,0,0,318,51,1,0,0,0,319,317,1,
        0,0,0,320,321,5,29,0,0,321,322,5,17,0,0,322,323,5,32,0,0,323,324,
        5,35,0,0,324,53,1,0,0,0,325,329,5,18,0,0,326,328,5,35,0,0,327,326,
        1,0,0,0,328,331,1,0,0,0,329,327,1,0,0,0,329,330,1,0,0,0,330,332,
        1,0,0,0,331,329,1,0,0,0,332,338,3,56,28,0,333,334,5,35,0,0,334,335,
        5,35,0,0,335,337,3,56,28,0,336,333,1,0,0,0,337,340,1,0,0,0,338,336,
        1,0,0,0,338,339,1,0,0,0,339,55,1,0,0,0,340,338,1,0,0,0,341,343,5,
        19,0,0,342,344,5,29,0,0,343,342,1,0,0,0,344,345,1,0,0,0,345,343,
        1,0,0,0,345,346,1,0,0,0,346,350,1,0,0,0,347,349,5,35,0,0,348,347,
        1,0,0,0,349,352,1,0,0,0,350,348,1,0,0,0,350,351,1,0,0,0,351,353,
        1,0,0,0,352,350,1,0,0,0,353,355,5,20,0,0,354,356,5,29,0,0,355,354,
        1,0,0,0,356,357,1,0,0,0,357,355,1,0,0,0,357,358,1,0,0,0,358,362,
        1,0,0,0,359,361,5,35,0,0,360,359,1,0,0,0,361,364,1,0,0,0,362,360,
        1,0,0,0,362,363,1,0,0,0,363,365,1,0,0,0,364,362,1,0,0,0,365,366,
        5,15,0,0,366,370,5,32,0,0,367,369,5,35,0,0,368,367,1,0,0,0,369,372,
        1,0,0,0,370,368,1,0,0,0,370,371,1,0,0,0,371,57,1,0,0,0,372,370,1,
        0,0,0,373,377,5,21,0,0,374,376,5,35,0,0,375,374,1,0,0,0,376,379,
        1,0,0,0,377,375,1,0,0,0,377,378,1,0,0,0,378,380,1,0,0,0,379,377,
        1,0,0,0,380,386,3,60,30,0,381,382,5,35,0,0,382,383,5,35,0,0,383,
        385,3,60,30,0,384,381,1,0,0,0,385,388,1,0,0,0,386,384,1,0,0,0,386,
        387,1,0,0,0,387,59,1,0,0,0,388,386,1,0,0,0,389,391,5,22,0,0,390,
        392,5,29,0,0,391,390,1,0,0,0,392,393,1,0,0,0,393,391,1,0,0,0,393,
        394,1,0,0,0,394,398,1,0,0,0,395,397,5,35,0,0,396,395,1,0,0,0,397,
        400,1,0,0,0,398,396,1,0,0,0,398,399,1,0,0,0,399,401,1,0,0,0,400,
        398,1,0,0,0,401,403,5,23,0,0,402,404,5,29,0,0,403,402,1,0,0,0,404,
        405,1,0,0,0,405,403,1,0,0,0,405,406,1,0,0,0,406,410,1,0,0,0,407,
        409,5,35,0,0,408,407,1,0,0,0,409,412,1,0,0,0,410,408,1,0,0,0,410,
        411,1,0,0,0,411,413,1,0,0,0,412,410,1,0,0,0,413,415,5,24,0,0,414,
        416,5,29,0,0,415,414,1,0,0,0,416,417,1,0,0,0,417,415,1,0,0,0,417,
        418,1,0,0,0,418,422,1,0,0,0,419,421,5,35,0,0,420,419,1,0,0,0,421,
        424,1,0,0,0,422,420,1,0,0,0,422,423,1,0,0,0,423,425,1,0,0,0,424,
        422,1,0,0,0,425,427,5,25,0,0,426,428,5,29,0,0,427,426,1,0,0,0,428,
        429,1,0,0,0,429,427,1,0,0,0,429,430,1,0,0,0,430,434,1,0,0,0,431,
        433,5,35,0,0,432,431,1,0,0,0,433,436,1,0,0,0,434,432,1,0,0,0,434,
        435,1,0,0,0,435,437,1,0,0,0,436,434,1,0,0,0,437,438,5,26,0,0,438,
        439,5,35,0,0,439,440,3,62,31,0,440,61,1,0,0,0,441,446,3,64,32,0,
        442,443,5,35,0,0,443,445,3,64,32,0,444,442,1,0,0,0,445,448,1,0,0,
        0,446,444,1,0,0,0,446,447,1,0,0,0,447,63,1,0,0,0,448,446,1,0,0,0,
        449,451,5,29,0,0,450,449,1,0,0,0,451,452,1,0,0,0,452,450,1,0,0,0,
        452,453,1,0,0,0,453,65,1,0,0,0,454,455,5,27,0,0,455,456,5,35,0,0,
        456,462,3,68,34,0,457,458,5,35,0,0,458,459,5,35,0,0,459,461,3,68,
        34,0,460,457,1,0,0,0,461,464,1,0,0,0,462,460,1,0,0,0,462,463,1,0,
        0,0,463,67,1,0,0,0,464,462,1,0,0,0,465,467,5,14,0,0,466,468,5,29,
        0,0,467,466,1,0,0,0,468,469,1,0,0,0,469,467,1,0,0,0,469,470,1,0,
        0,0,470,474,1,0,0,0,471,473,5,35,0,0,472,471,1,0,0,0,473,476,1,0,
        0,0,474,472,1,0,0,0,474,475,1,0,0,0,475,477,1,0,0,0,476,474,1,0,
        0,0,477,479,5,28,0,0,478,480,5,29,0,0,479,478,1,0,0,0,480,481,1,
        0,0,0,481,479,1,0,0,0,481,482,1,0,0,0,482,486,1,0,0,0,483,485,5,
        35,0,0,484,483,1,0,0,0,485,488,1,0,0,0,486,484,1,0,0,0,486,487,1,
        0,0,0,487,489,1,0,0,0,488,486,1,0,0,0,489,491,5,24,0,0,490,492,5,
        29,0,0,491,490,1,0,0,0,492,493,1,0,0,0,493,491,1,0,0,0,493,494,1,
        0,0,0,494,498,1,0,0,0,495,497,5,35,0,0,496,495,1,0,0,0,497,500,1,
        0,0,0,498,496,1,0,0,0,498,499,1,0,0,0,499,501,1,0,0,0,500,498,1,
        0,0,0,501,503,5,25,0,0,502,504,5,29,0,0,503,502,1,0,0,0,504,505,
        1,0,0,0,505,503,1,0,0,0,505,506,1,0,0,0,506,510,1,0,0,0,507,509,
        5,35,0,0,508,507,1,0,0,0,509,512,1,0,0,0,510,508,1,0,0,0,510,511,
        1,0,0,0,511,69,1,0,0,0,512,510,1,0,0,0,65,77,81,86,90,95,99,104,
        108,113,117,122,126,131,135,161,166,171,176,183,191,199,203,208,
        212,221,227,240,246,257,267,275,282,287,294,299,307,317,329,338,
        345,350,357,362,370,377,386,393,398,405,410,417,422,429,434,446,
        452,462,469,474,481,486,493,498,505,510
    ]

class ResumeParser ( Parser ):

    grammarFileName = "Resume.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'name:'", "'surname:'", "'job_title:'", 
                     "'phone: '", "'city:'", "'gmail:'", "'birth:'", "'summary:'", 
                     "'hard_skills:'", "','", "'soft_skills:'", "'languages:'", 
                     "'certificates:'", "'institution:'", "'link:'", "'socials:'", 
                     "':'", "'projects:'", "'title:'", "'description:'", 
                     "'work_experience:'", "'company:'", "'position:'", 
                     "'start_date:'", "'end_date:'", "'responsibilities:'", 
                     "'educations:'", "'degree:'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "TEXT", "PHONE", "EMAIL", "URL", "RATING", 
                      "WS", "NEWLINE" ]

    RULE_start = 0
    RULE_resume = 1
    RULE_personal_info = 2
    RULE_name = 3
    RULE_surname = 4
    RULE_job_title = 5
    RULE_birth = 6
    RULE_phone = 7
    RULE_city = 8
    RULE_gmail = 9
    RULE_summary = 10
    RULE_skills = 11
    RULE_hard_skills = 12
    RULE_hard_skill_list = 13
    RULE_hard_skill = 14
    RULE_soft_skills = 15
    RULE_soft_skill_list = 16
    RULE_soft_skill = 17
    RULE_languages = 18
    RULE_language_list = 19
    RULE_language = 20
    RULE_certificates = 21
    RULE_certificate_list = 22
    RULE_certificate = 23
    RULE_socials = 24
    RULE_social_list = 25
    RULE_social = 26
    RULE_projects = 27
    RULE_project = 28
    RULE_work_experience = 29
    RULE_job = 30
    RULE_responsibility_list = 31
    RULE_responsibility = 32
    RULE_educations = 33
    RULE_education = 34

    ruleNames =  [ "start", "resume", "personal_info", "name", "surname", 
                   "job_title", "birth", "phone", "city", "gmail", "summary", 
                   "skills", "hard_skills", "hard_skill_list", "hard_skill", 
                   "soft_skills", "soft_skill_list", "soft_skill", "languages", 
                   "language_list", "language", "certificates", "certificate_list", 
                   "certificate", "socials", "social_list", "social", "projects", 
                   "project", "work_experience", "job", "responsibility_list", 
                   "responsibility", "educations", "education" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    TEXT=29
    PHONE=30
    EMAIL=31
    URL=32
    RATING=33
    WS=34
    NEWLINE=35

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def resume(self):
            return self.getTypedRuleContext(ResumeParser.ResumeContext,0)


        def EOF(self):
            return self.getToken(ResumeParser.EOF, 0)

        def getRuleIndex(self):
            return ResumeParser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStart" ):
                return visitor.visitStart(self)
            else:
                return visitor.visitChildren(self)




    def start(self):

        localctx = ResumeParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 70
            self.resume()
            self.state = 71
            self.match(ResumeParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResumeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def personal_info(self):
            return self.getTypedRuleContext(ResumeParser.Personal_infoContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.NEWLINE)
            else:
                return self.getToken(ResumeParser.NEWLINE, i)

        def summary(self):
            return self.getTypedRuleContext(ResumeParser.SummaryContext,0)


        def skills(self):
            return self.getTypedRuleContext(ResumeParser.SkillsContext,0)


        def certificates(self):
            return self.getTypedRuleContext(ResumeParser.CertificatesContext,0)


        def socials(self):
            return self.getTypedRuleContext(ResumeParser.SocialsContext,0)


        def projects(self):
            return self.getTypedRuleContext(ResumeParser.ProjectsContext,0)


        def work_experience(self):
            return self.getTypedRuleContext(ResumeParser.Work_experienceContext,0)


        def educations(self):
            return self.getTypedRuleContext(ResumeParser.EducationsContext,0)


        def getRuleIndex(self):
            return ResumeParser.RULE_resume

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResume" ):
                listener.enterResume(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResume" ):
                listener.exitResume(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResume" ):
                return visitor.visitResume(self)
            else:
                return visitor.visitChildren(self)




    def resume(self):

        localctx = ResumeParser.ResumeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_resume)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 73
            self.personal_info()
            self.state = 77
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 74
                    self.match(ResumeParser.NEWLINE) 
                self.state = 79
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

            self.state = 81
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 80
                self.summary()


            self.state = 86
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 83
                    self.match(ResumeParser.NEWLINE) 
                self.state = 88
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

            self.state = 90
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==9:
                self.state = 89
                self.skills()


            self.state = 95
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 92
                    self.match(ResumeParser.NEWLINE) 
                self.state = 97
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

            self.state = 99
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 98
                self.certificates()


            self.state = 104
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 101
                    self.match(ResumeParser.NEWLINE) 
                self.state = 106
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

            self.state = 108
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==16:
                self.state = 107
                self.socials()


            self.state = 113
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 110
                    self.match(ResumeParser.NEWLINE) 
                self.state = 115
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==18:
                self.state = 116
                self.projects()


            self.state = 122
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 119
                    self.match(ResumeParser.NEWLINE) 
                self.state = 124
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

            self.state = 126
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==21:
                self.state = 125
                self.work_experience()


            self.state = 131
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 128
                self.match(ResumeParser.NEWLINE)
                self.state = 133
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 135
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27:
                self.state = 134
                self.educations()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Personal_infoContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(ResumeParser.NameContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.NEWLINE)
            else:
                return self.getToken(ResumeParser.NEWLINE, i)

        def surname(self):
            return self.getTypedRuleContext(ResumeParser.SurnameContext,0)


        def job_title(self):
            return self.getTypedRuleContext(ResumeParser.Job_titleContext,0)


        def phone(self):
            return self.getTypedRuleContext(ResumeParser.PhoneContext,0)


        def city(self):
            return self.getTypedRuleContext(ResumeParser.CityContext,0)


        def gmail(self):
            return self.getTypedRuleContext(ResumeParser.GmailContext,0)


        def birth(self):
            return self.getTypedRuleContext(ResumeParser.BirthContext,0)


        def getRuleIndex(self):
            return ResumeParser.RULE_personal_info

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPersonal_info" ):
                listener.enterPersonal_info(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPersonal_info" ):
                listener.exitPersonal_info(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPersonal_info" ):
                return visitor.visitPersonal_info(self)
            else:
                return visitor.visitChildren(self)




    def personal_info(self):

        localctx = ResumeParser.Personal_infoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_personal_info)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.match(ResumeParser.T__0)
            self.state = 138
            self.name()
            self.state = 139
            self.match(ResumeParser.NEWLINE)
            self.state = 140
            self.match(ResumeParser.T__1)
            self.state = 141
            self.surname()
            self.state = 142
            self.match(ResumeParser.NEWLINE)
            self.state = 143
            self.match(ResumeParser.T__2)
            self.state = 144
            self.job_title()
            self.state = 145
            self.match(ResumeParser.NEWLINE)
            self.state = 146
            self.match(ResumeParser.T__3)
            self.state = 147
            self.phone()
            self.state = 148
            self.match(ResumeParser.NEWLINE)
            self.state = 149
            self.match(ResumeParser.T__4)
            self.state = 150
            self.city()
            self.state = 151
            self.match(ResumeParser.NEWLINE)
            self.state = 152
            self.match(ResumeParser.T__5)
            self.state = 153
            self.gmail()
            self.state = 154
            self.match(ResumeParser.NEWLINE)
            self.state = 155
            self.match(ResumeParser.T__6)
            self.state = 156
            self.birth()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.TEXT)
            else:
                return self.getToken(ResumeParser.TEXT, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = ResumeParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 159 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 158
                self.match(ResumeParser.TEXT)
                self.state = 161 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SurnameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.TEXT)
            else:
                return self.getToken(ResumeParser.TEXT, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_surname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSurname" ):
                listener.enterSurname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSurname" ):
                listener.exitSurname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSurname" ):
                return visitor.visitSurname(self)
            else:
                return visitor.visitChildren(self)




    def surname(self):

        localctx = ResumeParser.SurnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_surname)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 163
                self.match(ResumeParser.TEXT)
                self.state = 166 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Job_titleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.TEXT)
            else:
                return self.getToken(ResumeParser.TEXT, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_job_title

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJob_title" ):
                listener.enterJob_title(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJob_title" ):
                listener.exitJob_title(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJob_title" ):
                return visitor.visitJob_title(self)
            else:
                return visitor.visitChildren(self)




    def job_title(self):

        localctx = ResumeParser.Job_titleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_job_title)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 169 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 168
                self.match(ResumeParser.TEXT)
                self.state = 171 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BirthContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.TEXT)
            else:
                return self.getToken(ResumeParser.TEXT, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_birth

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBirth" ):
                listener.enterBirth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBirth" ):
                listener.exitBirth(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBirth" ):
                return visitor.visitBirth(self)
            else:
                return visitor.visitChildren(self)




    def birth(self):

        localctx = ResumeParser.BirthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_birth)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 173
                self.match(ResumeParser.TEXT)
                self.state = 176 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PhoneContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PHONE(self):
            return self.getToken(ResumeParser.PHONE, 0)

        def getRuleIndex(self):
            return ResumeParser.RULE_phone

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPhone" ):
                listener.enterPhone(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPhone" ):
                listener.exitPhone(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPhone" ):
                return visitor.visitPhone(self)
            else:
                return visitor.visitChildren(self)




    def phone(self):

        localctx = ResumeParser.PhoneContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_phone)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            self.match(ResumeParser.PHONE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.TEXT)
            else:
                return self.getToken(ResumeParser.TEXT, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_city

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCity" ):
                listener.enterCity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCity" ):
                listener.exitCity(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCity" ):
                return visitor.visitCity(self)
            else:
                return visitor.visitChildren(self)




    def city(self):

        localctx = ResumeParser.CityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_city)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 180
                self.match(ResumeParser.TEXT)
                self.state = 183 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GmailContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EMAIL(self):
            return self.getToken(ResumeParser.EMAIL, 0)

        def getRuleIndex(self):
            return ResumeParser.RULE_gmail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGmail" ):
                listener.enterGmail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGmail" ):
                listener.exitGmail(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGmail" ):
                return visitor.visitGmail(self)
            else:
                return visitor.visitChildren(self)




    def gmail(self):

        localctx = ResumeParser.GmailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_gmail)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            self.match(ResumeParser.EMAIL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SummaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self):
            return self.getToken(ResumeParser.NEWLINE, 0)

        def TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.TEXT)
            else:
                return self.getToken(ResumeParser.TEXT, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_summary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSummary" ):
                listener.enterSummary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSummary" ):
                listener.exitSummary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSummary" ):
                return visitor.visitSummary(self)
            else:
                return visitor.visitChildren(self)




    def summary(self):

        localctx = ResumeParser.SummaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_summary)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 187
            self.match(ResumeParser.T__7)
            self.state = 189 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 188
                self.match(ResumeParser.TEXT)
                self.state = 191 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 193
            self.match(ResumeParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SkillsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def hard_skills(self):
            return self.getTypedRuleContext(ResumeParser.Hard_skillsContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.NEWLINE)
            else:
                return self.getToken(ResumeParser.NEWLINE, i)

        def soft_skills(self):
            return self.getTypedRuleContext(ResumeParser.Soft_skillsContext,0)


        def languages(self):
            return self.getTypedRuleContext(ResumeParser.LanguagesContext,0)


        def getRuleIndex(self):
            return ResumeParser.RULE_skills

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSkills" ):
                listener.enterSkills(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSkills" ):
                listener.exitSkills(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSkills" ):
                return visitor.visitSkills(self)
            else:
                return visitor.visitChildren(self)




    def skills(self):

        localctx = ResumeParser.SkillsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_skills)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            self.hard_skills()
            self.state = 199
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,20,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 196
                    self.match(ResumeParser.NEWLINE) 
                self.state = 201
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

            self.state = 203
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 202
                self.soft_skills()


            self.state = 208
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,22,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 205
                    self.match(ResumeParser.NEWLINE) 
                self.state = 210
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,22,self._ctx)

            self.state = 212
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 211
                self.languages()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Hard_skillsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self):
            return self.getToken(ResumeParser.NEWLINE, 0)

        def hard_skill_list(self):
            return self.getTypedRuleContext(ResumeParser.Hard_skill_listContext,0)


        def getRuleIndex(self):
            return ResumeParser.RULE_hard_skills

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHard_skills" ):
                listener.enterHard_skills(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHard_skills" ):
                listener.exitHard_skills(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHard_skills" ):
                return visitor.visitHard_skills(self)
            else:
                return visitor.visitChildren(self)




    def hard_skills(self):

        localctx = ResumeParser.Hard_skillsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_hard_skills)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            self.match(ResumeParser.T__8)
            self.state = 215
            self.match(ResumeParser.NEWLINE)
            self.state = 216
            self.hard_skill_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Hard_skill_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def hard_skill(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ResumeParser.Hard_skillContext)
            else:
                return self.getTypedRuleContext(ResumeParser.Hard_skillContext,i)


        def getRuleIndex(self):
            return ResumeParser.RULE_hard_skill_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHard_skill_list" ):
                listener.enterHard_skill_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHard_skill_list" ):
                listener.exitHard_skill_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHard_skill_list" ):
                return visitor.visitHard_skill_list(self)
            else:
                return visitor.visitChildren(self)




    def hard_skill_list(self):

        localctx = ResumeParser.Hard_skill_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_hard_skill_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 221
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 218
                self.hard_skill()
                self.state = 223
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Hard_skillContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.TEXT)
            else:
                return self.getToken(ResumeParser.TEXT, i)

        def NEWLINE(self):
            return self.getToken(ResumeParser.NEWLINE, 0)

        def getRuleIndex(self):
            return ResumeParser.RULE_hard_skill

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHard_skill" ):
                listener.enterHard_skill(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHard_skill" ):
                listener.exitHard_skill(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHard_skill" ):
                return visitor.visitHard_skill(self)
            else:
                return visitor.visitChildren(self)




    def hard_skill(self):

        localctx = ResumeParser.Hard_skillContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_hard_skill)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 225 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 224
                self.match(ResumeParser.TEXT)
                self.state = 227 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 229
            self.match(ResumeParser.T__9)
            self.state = 230
            self.match(ResumeParser.TEXT)
            self.state = 231
            self.match(ResumeParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Soft_skillsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self):
            return self.getToken(ResumeParser.NEWLINE, 0)

        def soft_skill_list(self):
            return self.getTypedRuleContext(ResumeParser.Soft_skill_listContext,0)


        def getRuleIndex(self):
            return ResumeParser.RULE_soft_skills

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSoft_skills" ):
                listener.enterSoft_skills(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSoft_skills" ):
                listener.exitSoft_skills(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSoft_skills" ):
                return visitor.visitSoft_skills(self)
            else:
                return visitor.visitChildren(self)




    def soft_skills(self):

        localctx = ResumeParser.Soft_skillsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_soft_skills)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.match(ResumeParser.T__10)
            self.state = 234
            self.match(ResumeParser.NEWLINE)
            self.state = 235
            self.soft_skill_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Soft_skill_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def soft_skill(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ResumeParser.Soft_skillContext)
            else:
                return self.getTypedRuleContext(ResumeParser.Soft_skillContext,i)


        def getRuleIndex(self):
            return ResumeParser.RULE_soft_skill_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSoft_skill_list" ):
                listener.enterSoft_skill_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSoft_skill_list" ):
                listener.exitSoft_skill_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSoft_skill_list" ):
                return visitor.visitSoft_skill_list(self)
            else:
                return visitor.visitChildren(self)




    def soft_skill_list(self):

        localctx = ResumeParser.Soft_skill_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_soft_skill_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 237
                self.soft_skill()
                self.state = 242
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Soft_skillContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self):
            return self.getToken(ResumeParser.NEWLINE, 0)

        def TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.TEXT)
            else:
                return self.getToken(ResumeParser.TEXT, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_soft_skill

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSoft_skill" ):
                listener.enterSoft_skill(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSoft_skill" ):
                listener.exitSoft_skill(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSoft_skill" ):
                return visitor.visitSoft_skill(self)
            else:
                return visitor.visitChildren(self)




    def soft_skill(self):

        localctx = ResumeParser.Soft_skillContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_soft_skill)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 244 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 243
                self.match(ResumeParser.TEXT)
                self.state = 246 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 248
            self.match(ResumeParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LanguagesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self):
            return self.getToken(ResumeParser.NEWLINE, 0)

        def language_list(self):
            return self.getTypedRuleContext(ResumeParser.Language_listContext,0)


        def getRuleIndex(self):
            return ResumeParser.RULE_languages

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLanguages" ):
                listener.enterLanguages(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLanguages" ):
                listener.exitLanguages(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLanguages" ):
                return visitor.visitLanguages(self)
            else:
                return visitor.visitChildren(self)




    def languages(self):

        localctx = ResumeParser.LanguagesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_languages)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.match(ResumeParser.T__11)
            self.state = 251
            self.match(ResumeParser.NEWLINE)
            self.state = 252
            self.language_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Language_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def language(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ResumeParser.LanguageContext)
            else:
                return self.getTypedRuleContext(ResumeParser.LanguageContext,i)


        def getRuleIndex(self):
            return ResumeParser.RULE_language_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLanguage_list" ):
                listener.enterLanguage_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLanguage_list" ):
                listener.exitLanguage_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLanguage_list" ):
                return visitor.visitLanguage_list(self)
            else:
                return visitor.visitChildren(self)




    def language_list(self):

        localctx = ResumeParser.Language_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_language_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 257
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 254
                self.language()
                self.state = 259
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LanguageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT(self):
            return self.getToken(ResumeParser.TEXT, 0)

        def NEWLINE(self):
            return self.getToken(ResumeParser.NEWLINE, 0)

        def getRuleIndex(self):
            return ResumeParser.RULE_language

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLanguage" ):
                listener.enterLanguage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLanguage" ):
                listener.exitLanguage(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLanguage" ):
                return visitor.visitLanguage(self)
            else:
                return visitor.visitChildren(self)




    def language(self):

        localctx = ResumeParser.LanguageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_language)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            self.match(ResumeParser.TEXT)
            self.state = 261
            self.match(ResumeParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CertificatesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def certificate_list(self):
            return self.getTypedRuleContext(ResumeParser.Certificate_listContext,0)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.NEWLINE)
            else:
                return self.getToken(ResumeParser.NEWLINE, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_certificates

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCertificates" ):
                listener.enterCertificates(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCertificates" ):
                listener.exitCertificates(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCertificates" ):
                return visitor.visitCertificates(self)
            else:
                return visitor.visitChildren(self)




    def certificates(self):

        localctx = ResumeParser.CertificatesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_certificates)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 263
            self.match(ResumeParser.T__12)
            self.state = 267
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,29,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 264
                    self.match(ResumeParser.NEWLINE) 
                self.state = 269
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,29,self._ctx)

            self.state = 270
            self.certificate_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Certificate_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def certificate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ResumeParser.CertificateContext)
            else:
                return self.getTypedRuleContext(ResumeParser.CertificateContext,i)


        def getRuleIndex(self):
            return ResumeParser.RULE_certificate_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCertificate_list" ):
                listener.enterCertificate_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCertificate_list" ):
                listener.exitCertificate_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCertificate_list" ):
                return visitor.visitCertificate_list(self)
            else:
                return visitor.visitChildren(self)




    def certificate_list(self):

        localctx = ResumeParser.Certificate_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_certificate_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 275
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1:
                self.state = 272
                self.certificate()
                self.state = 277
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CertificateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def URL(self):
            return self.getToken(ResumeParser.URL, 0)

        def TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.TEXT)
            else:
                return self.getToken(ResumeParser.TEXT, i)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.NEWLINE)
            else:
                return self.getToken(ResumeParser.NEWLINE, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_certificate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCertificate" ):
                listener.enterCertificate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCertificate" ):
                listener.exitCertificate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCertificate" ):
                return visitor.visitCertificate(self)
            else:
                return visitor.visitChildren(self)




    def certificate(self):

        localctx = ResumeParser.CertificateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_certificate)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 278
            self.match(ResumeParser.T__0)
            self.state = 280 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 279
                self.match(ResumeParser.TEXT)
                self.state = 282 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 287
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 284
                self.match(ResumeParser.NEWLINE)
                self.state = 289
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 290
            self.match(ResumeParser.T__13)
            self.state = 292 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 291
                self.match(ResumeParser.TEXT)
                self.state = 294 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 299
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 296
                self.match(ResumeParser.NEWLINE)
                self.state = 301
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 302
            self.match(ResumeParser.T__14)
            self.state = 303
            self.match(ResumeParser.URL)
            self.state = 307
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,35,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 304
                    self.match(ResumeParser.NEWLINE) 
                self.state = 309
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,35,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SocialsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self):
            return self.getToken(ResumeParser.NEWLINE, 0)

        def social_list(self):
            return self.getTypedRuleContext(ResumeParser.Social_listContext,0)


        def getRuleIndex(self):
            return ResumeParser.RULE_socials

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSocials" ):
                listener.enterSocials(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSocials" ):
                listener.exitSocials(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSocials" ):
                return visitor.visitSocials(self)
            else:
                return visitor.visitChildren(self)




    def socials(self):

        localctx = ResumeParser.SocialsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_socials)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 310
            self.match(ResumeParser.T__15)
            self.state = 311
            self.match(ResumeParser.NEWLINE)
            self.state = 312
            self.social_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Social_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def social(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ResumeParser.SocialContext)
            else:
                return self.getTypedRuleContext(ResumeParser.SocialContext,i)


        def getRuleIndex(self):
            return ResumeParser.RULE_social_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSocial_list" ):
                listener.enterSocial_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSocial_list" ):
                listener.exitSocial_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSocial_list" ):
                return visitor.visitSocial_list(self)
            else:
                return visitor.visitChildren(self)




    def social_list(self):

        localctx = ResumeParser.Social_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_social_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 317
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 314
                self.social()
                self.state = 319
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SocialContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT(self):
            return self.getToken(ResumeParser.TEXT, 0)

        def URL(self):
            return self.getToken(ResumeParser.URL, 0)

        def NEWLINE(self):
            return self.getToken(ResumeParser.NEWLINE, 0)

        def getRuleIndex(self):
            return ResumeParser.RULE_social

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSocial" ):
                listener.enterSocial(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSocial" ):
                listener.exitSocial(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSocial" ):
                return visitor.visitSocial(self)
            else:
                return visitor.visitChildren(self)




    def social(self):

        localctx = ResumeParser.SocialContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_social)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 320
            self.match(ResumeParser.TEXT)
            self.state = 321
            self.match(ResumeParser.T__16)
            self.state = 322
            self.match(ResumeParser.URL)
            self.state = 323
            self.match(ResumeParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ResumeParser.ProjectContext)
            else:
                return self.getTypedRuleContext(ResumeParser.ProjectContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.NEWLINE)
            else:
                return self.getToken(ResumeParser.NEWLINE, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_projects

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProjects" ):
                listener.enterProjects(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProjects" ):
                listener.exitProjects(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProjects" ):
                return visitor.visitProjects(self)
            else:
                return visitor.visitChildren(self)




    def projects(self):

        localctx = ResumeParser.ProjectsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_projects)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 325
            self.match(ResumeParser.T__17)
            self.state = 329
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 326
                self.match(ResumeParser.NEWLINE)
                self.state = 331
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 332
            self.project()
            self.state = 338
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,38,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 333
                    self.match(ResumeParser.NEWLINE)
                    self.state = 334
                    self.match(ResumeParser.NEWLINE)
                    self.state = 335
                    self.project() 
                self.state = 340
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,38,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProjectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def URL(self):
            return self.getToken(ResumeParser.URL, 0)

        def TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.TEXT)
            else:
                return self.getToken(ResumeParser.TEXT, i)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.NEWLINE)
            else:
                return self.getToken(ResumeParser.NEWLINE, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_project

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject" ):
                listener.enterProject(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject" ):
                listener.exitProject(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProject" ):
                return visitor.visitProject(self)
            else:
                return visitor.visitChildren(self)




    def project(self):

        localctx = ResumeParser.ProjectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_project)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 341
            self.match(ResumeParser.T__18)
            self.state = 343 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 342
                self.match(ResumeParser.TEXT)
                self.state = 345 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 350
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 347
                self.match(ResumeParser.NEWLINE)
                self.state = 352
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 353
            self.match(ResumeParser.T__19)
            self.state = 355 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 354
                self.match(ResumeParser.TEXT)
                self.state = 357 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 362
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 359
                self.match(ResumeParser.NEWLINE)
                self.state = 364
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 365
            self.match(ResumeParser.T__14)
            self.state = 366
            self.match(ResumeParser.URL)
            self.state = 370
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,43,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 367
                    self.match(ResumeParser.NEWLINE) 
                self.state = 372
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,43,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Work_experienceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def job(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ResumeParser.JobContext)
            else:
                return self.getTypedRuleContext(ResumeParser.JobContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.NEWLINE)
            else:
                return self.getToken(ResumeParser.NEWLINE, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_work_experience

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWork_experience" ):
                listener.enterWork_experience(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWork_experience" ):
                listener.exitWork_experience(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWork_experience" ):
                return visitor.visitWork_experience(self)
            else:
                return visitor.visitChildren(self)




    def work_experience(self):

        localctx = ResumeParser.Work_experienceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_work_experience)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 373
            self.match(ResumeParser.T__20)
            self.state = 377
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 374
                self.match(ResumeParser.NEWLINE)
                self.state = 379
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 380
            self.job()
            self.state = 386
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,45,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 381
                    self.match(ResumeParser.NEWLINE)
                    self.state = 382
                    self.match(ResumeParser.NEWLINE)
                    self.state = 383
                    self.job() 
                self.state = 388
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,45,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JobContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.NEWLINE)
            else:
                return self.getToken(ResumeParser.NEWLINE, i)

        def responsibility_list(self):
            return self.getTypedRuleContext(ResumeParser.Responsibility_listContext,0)


        def TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.TEXT)
            else:
                return self.getToken(ResumeParser.TEXT, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_job

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJob" ):
                listener.enterJob(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJob" ):
                listener.exitJob(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJob" ):
                return visitor.visitJob(self)
            else:
                return visitor.visitChildren(self)




    def job(self):

        localctx = ResumeParser.JobContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_job)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 389
            self.match(ResumeParser.T__21)
            self.state = 391 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 390
                self.match(ResumeParser.TEXT)
                self.state = 393 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 398
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 395
                self.match(ResumeParser.NEWLINE)
                self.state = 400
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 401
            self.match(ResumeParser.T__22)
            self.state = 403 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 402
                self.match(ResumeParser.TEXT)
                self.state = 405 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 410
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 407
                self.match(ResumeParser.NEWLINE)
                self.state = 412
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 413
            self.match(ResumeParser.T__23)
            self.state = 415 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 414
                self.match(ResumeParser.TEXT)
                self.state = 417 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 422
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 419
                self.match(ResumeParser.NEWLINE)
                self.state = 424
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 425
            self.match(ResumeParser.T__24)
            self.state = 427 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 426
                self.match(ResumeParser.TEXT)
                self.state = 429 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 434
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 431
                self.match(ResumeParser.NEWLINE)
                self.state = 436
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 437
            self.match(ResumeParser.T__25)
            self.state = 438
            self.match(ResumeParser.NEWLINE)
            self.state = 439
            self.responsibility_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Responsibility_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def responsibility(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ResumeParser.ResponsibilityContext)
            else:
                return self.getTypedRuleContext(ResumeParser.ResponsibilityContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.NEWLINE)
            else:
                return self.getToken(ResumeParser.NEWLINE, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_responsibility_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResponsibility_list" ):
                listener.enterResponsibility_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResponsibility_list" ):
                listener.exitResponsibility_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResponsibility_list" ):
                return visitor.visitResponsibility_list(self)
            else:
                return visitor.visitChildren(self)




    def responsibility_list(self):

        localctx = ResumeParser.Responsibility_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_responsibility_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 441
            self.responsibility()
            self.state = 446
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,54,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 442
                    self.match(ResumeParser.NEWLINE)
                    self.state = 443
                    self.responsibility() 
                self.state = 448
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,54,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResponsibilityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.TEXT)
            else:
                return self.getToken(ResumeParser.TEXT, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_responsibility

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResponsibility" ):
                listener.enterResponsibility(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResponsibility" ):
                listener.exitResponsibility(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResponsibility" ):
                return visitor.visitResponsibility(self)
            else:
                return visitor.visitChildren(self)




    def responsibility(self):

        localctx = ResumeParser.ResponsibilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_responsibility)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 450 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 449
                self.match(ResumeParser.TEXT)
                self.state = 452 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EducationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.NEWLINE)
            else:
                return self.getToken(ResumeParser.NEWLINE, i)

        def education(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ResumeParser.EducationContext)
            else:
                return self.getTypedRuleContext(ResumeParser.EducationContext,i)


        def getRuleIndex(self):
            return ResumeParser.RULE_educations

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEducations" ):
                listener.enterEducations(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEducations" ):
                listener.exitEducations(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEducations" ):
                return visitor.visitEducations(self)
            else:
                return visitor.visitChildren(self)




    def educations(self):

        localctx = ResumeParser.EducationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_educations)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 454
            self.match(ResumeParser.T__26)
            self.state = 455
            self.match(ResumeParser.NEWLINE)
            self.state = 456
            self.education()
            self.state = 462
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 457
                self.match(ResumeParser.NEWLINE)
                self.state = 458
                self.match(ResumeParser.NEWLINE)
                self.state = 459
                self.education()
                self.state = 464
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EducationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.TEXT)
            else:
                return self.getToken(ResumeParser.TEXT, i)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ResumeParser.NEWLINE)
            else:
                return self.getToken(ResumeParser.NEWLINE, i)

        def getRuleIndex(self):
            return ResumeParser.RULE_education

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEducation" ):
                listener.enterEducation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEducation" ):
                listener.exitEducation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEducation" ):
                return visitor.visitEducation(self)
            else:
                return visitor.visitChildren(self)




    def education(self):

        localctx = ResumeParser.EducationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_education)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 465
            self.match(ResumeParser.T__13)
            self.state = 467 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 466
                self.match(ResumeParser.TEXT)
                self.state = 469 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 474
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 471
                self.match(ResumeParser.NEWLINE)
                self.state = 476
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 477
            self.match(ResumeParser.T__27)
            self.state = 479 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 478
                self.match(ResumeParser.TEXT)
                self.state = 481 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 486
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 483
                self.match(ResumeParser.NEWLINE)
                self.state = 488
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 489
            self.match(ResumeParser.T__23)
            self.state = 491 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 490
                self.match(ResumeParser.TEXT)
                self.state = 493 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 498
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==35:
                self.state = 495
                self.match(ResumeParser.NEWLINE)
                self.state = 500
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 501
            self.match(ResumeParser.T__24)
            self.state = 503 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 502
                self.match(ResumeParser.TEXT)
                self.state = 505 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==29):
                    break

            self.state = 510
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,64,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 507
                    self.match(ResumeParser.NEWLINE) 
                self.state = 512
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,64,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





